@startuml Aplikacija produktivnosti in organizacije 
skinparam class {
  backgroundColor white
  borderColor #5FB8EC
  arrowColor black
}
skinparam class<<entity>> {
  backgroundColor #e8f5fc
  borderColor Blue
}
skinparam class<<control>> {
  backgroundColor #fce8e8
  borderColor Red
}
skinparam class<<boundary>> {
  backgroundColor #f2fce8
  borderColor Green
}

'skinparam shadowing false
skinparam defaultTextAlignment center
skinparam packageStyle rectangle
skinparam groupInheritance 2
hide circle
'hide members

'---------Razredi---------------------------
package Factory{
  Class User<<entity>> {
    -id: int
    -name: string
    -hash: string
    -salt: string 
    +getName(): string
    +setPassword(password: string): void
    +isPasswordCorrect(password: string): boolean
  }
  Class UserFactory<<control>>{
    +createUser(userType: string): User
  }
  Class SignedUser<<entity>>{

  }
  Class Admin<<entity>>{
    -mail: string
  }
  Class Analyst<<entity>>{

  }
  Class Developer<<entity>>{

  }
  Class UnsignedUser<<entity>> {
    -task Task []
  }
  Class SignedUserCreator<<control>>{
    +createUser(userType: string): void
  }
  Class AdminCreator<<control>>{
    +createUser(userType: string): void
  }
  Class DeveloperCreator<<control>>{
    +createUser(userType: string): void
  }
  Class AnalystCreator<<control>>{
    +createUser(userType: string): void
  }
}

Class ShowStatistics<<boundary>>{
  +showUserInfo(user: User)
}
  'proxy class? observer?
  '(timer alerta timedtask)
  'Class TimedTask<<entity>>{
  '  -id: int
  '  -name: string
  '  +getName(): void
  '}
Class Task<<entity>>{
  -id: int
  -name: string
  -description: string
  -date: date
  +setName(ime: string): string
  +setDescription(desc: string): string
  +getName(): string
  +getDescription(): string

}
class EditTasks<<control>>{
  +getTasks(user: User): Task []
  +addTask(user: UnsignedUser, Task: task): string
  +editTask(taskId: int, name: string, description: string): void
  +removeTask(taskId: int): void
}
class TaskWindow<<boundary>>{
  +showTasks(user: UnsignedUser): void
}
class WindowManager<<control>>{
  +openWindow(window: string): void
}
class Toolbar<<boundary>>{
  +openWindow(): void
}
Class Issue<<entity>>{
  -title: string
  -description: string
  -date: date
  -user: User
  -solved: boolean
  -solvedBy: Developer
  +solve(): void
  +getTitle(): string
  +getDescription(): string
}
Class IssueReport<<control>>{
  +addIssue(user: User, issue: Issue): void
  +getUnsolvedIssues(): Issue []
  +getSolvedIssues(user: Developer): Issue []
  +solveIssue(issue: Issue): void
}
Class IssueSolveWindow<<boundary>>{
  +showUnsolvedIssues(user: Developer): void
}
Class IssueReportWindow<<boundary>>

Class SearchUsers<<control>>{
  +findUser(name: string): User []
  +getUsers(): User []
}

' obvestiUsera - ko čas poteče, naredi popup al whatever. (better name pls)
' also a rabmo dodatne atribute/funkcije za pavzo?
Class Timer<<control>>{
  -currentTime: int
  -currentPause: int
  -isRunning: boolean
  -trajanje: int
  +startTimer(): void
  +resetTimer(): void
  +pauseTimer(): void
  +resumeTimer(): void
  +getCurrentTime(): void
  +alertUser(): void
}
Class TimerWindow<<boundary>>{
  +showCurrentTime(): void
}

'------Povezave-----------------------
Task --* UnsignedUser
'TimedTask --> Task
'EditTasks --> Task
EditTasks --> UnsignedUser
TaskWindow --> EditTasks
IssueReport --> Issue
IssueReportWindow --> IssueReport
IssueSolveWindow --> IssueReport
SearchUsers --> SignedUser
TimerWindow --> Timer
SignedUser --|> User
SignedUser --|> UnsignedUser
Analyst --|> User
Admin --|> User
Developer --|> User
ShowStatistics --> EditTasks
UserFactory --> User
SignedUserCreator --|> UserFactory
DeveloperCreator --|> UserFactory
AnalystCreator --|> UserFactory
AdminCreator --|> UserFactory
WindowManager --> IssueReportWindow
WindowManager --> TimerWindow
WindowManager --> ShowStatistics
WindowManager --> TaskWindow
WindowManager --> IssueSolveWindow
Toolbar --> WindowManager
@enduml

' extra notes
' - a se bolj fokusiramo da je čim boljši diagram al da
'    bo vse na diagramu dejansko implementirano?
' - Google calendar pokažeš kot boundary class
' loči Usera na frontend in backend z adapterjem
' načrtovalske vzorce se na koncu označi na diagramu
' POVEŽI ZASLONSKE MASKE SKUPAJ!
' logina ni treba dat noter.
' a je možno oz. je treba postaviti database connection v diagram?
' A moramo interface posebej označiti
' na diagramu ali je kar entity?
' Observer (MVC), Command pattern
' Singleton, strategy?